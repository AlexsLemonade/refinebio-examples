---
title: "Comparing Differential Expression Analysis"
author: "ALSF CCDL - Candace Savonen"
output:   
  html_notebook: 
    toc: true
    toc_float: true
---

*Purpose*: This notebook takes data processed by refine.bio and compares the 
differential expression results to the author-submitted versions of the data.

In this particular example, we are comparing two different medulloblastoma gene
expression datasets, and testing how much overlap we see in the gene lists obtained
from differential expression analyses.
The idea is that you may obtain differential expression results from your own 
data or a collaborator's data and want to compare it to a refine.bio dataset 
that measures a similar tissue and/or has a similar experimental set up.
This can be a quick way to see if your gene list results are generalizable to 
other datasets.

To represent differential expression results you may have obtained, we are using
[Northcott et al, 2012. Nature.](https://www.ncbi.nlm.nih.gov/pubmed/22832581)
using [author-processed data from Gene Expression Omnibus](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE37382). 
In another notebook in this module, `author_processed_DE.Rmd`, we used `limma` 
to compare medulloblastoma gene expression data from `SHH` subgroups versus the 
other subgroups and now. 
From this we obtained a table of output results (see `data/GSE37382_limma_results.tsv`)
that includes probe IDs, and their associated summary statistics from our 
differential expression testing. 

In this notebook, we are looking for whether the results we found in the Northcott
data are generalizable to [refine.bio dataset that also measures medulloblastoma subgroups](https://www.refine.bio/experiments/GSE37418/novel-mutations-target-distinct-subgroups-of-medulloblastoma).
These data are originally from [Robinson et al, 2012. Nature.](https://www.ncbi.nlm.nih.gov/pubmed/22722829) 
but were downloaded from refine.bio

The output from this notebook are two Venn diagrams showing the gene list overlap
between these two datasets' (one for up-regulated gene list, and the other for 
down-regulated). 

There are more than a few different possible approaches toward comparing two 
differential expression results, but this notebook's example takes the simplest
approach of looking at overlap of gene lists. 
This is partially so that this notebook's approach can be applied to any 
differential expression output, assuming that a gene list is the bare minimum
amount of result's information that one might obtain (regardless of source).

### What you will need to apply this dataset to your own results: 
At the bare minimum, you will need two gene lists, one for up-regulated and 
another for down-regulated genes. 

Ideally you will have table of differential expression results that will have:  

1) an indicator of gene association (eg. probe IDs, Ensembl gene IDs)  
2) an indicator of regulation direction (eg. fold change)  
3) an associated significance level (multiple testing corrected p-values)  

This example shows one method of summarizing and converting Affymetrix probe IDs
to Ensembl gene IDs, but depending on what type of gene identifiers and results
you have, you may need to do a few conversion steps. 

## 1) Set up

```{r}
if (!("limma" %in% installed.packages())) {
  # Install limma
  BiocManager::install("limma", update = FALSE)
}
if (!("VennDiagram" %in% installed.packages())) {
  # Install VennDiagram
  BiocManager::install("VennDiagram", update = FALSE)
}
```

Attach the `limma` library:

```{r}
# Magrittr pipe
`%>%` <- dplyr::`%>%`

# Attach library
library(limma)
```

Set up output directories if they haven't been set up yet.

```{r}
# Make a results directory if it isn't created yet
if (!dir.exists("results")) {
  dir.create("results")
}
# Make a plots directory if it isn't created yet
if (!dir.exists("plots")) {
  dir.create("plots")
}
```

## 2) Import differential expression results from Northcott dataset
Import the `limma` results obtained for the author-processed data for 
Northcott et al, 2012. 
If you'd like to see how we generated these results with `limma`, see
`author_processed_DE.Rmd` in this folder.
Note that these differential expression results come with Affymetrix probe IDs
(our source of gene identifier), `logFC`(our source of direction), and `adj.P.Val`
(our source of significance level).

```{r}
# Load in the summary statistics from limma run
author.full.results <- readr::read_tsv(file.path("results", 
                                                 "GSE37382_limma_results.tsv")) 
```

## 3) Convert the differentially expressed gene identifiers to Ensembl gene IDs
In refine.bio all IDs are converted to Ensembl gene IDs in the harmonization 
pipeline.
Here we need to convert our Affymetrix transcript cluster IDs into Ensembl gene
IDs so we can compare our datasets. 
If you are using this notebook for your own data, and need more information on
how to id conversion, you can look at `ensembl_id_convert.Rmd` in this repository
for more information. 
You can also use the [id conversion repository prepared by the CCDL.](https://github.com/AlexsLemonade/identifier-refinery) 
The pre-made id conversion key files themselves for refine.bio supported 
microarray platforms can be downloaded from [Zenodo](https://zenodo.org/record/1322711#.XLdJb-tKiXE). 

```{r}
# Unzip hugene11st id conversion file obtained from identifier refinery
id.conversion.file <- file.path("data", "hugene11st.tsv") 
if (!file.exists(id.conversion.file)) {
  unzip(paste0(id.conversion.file, ".zip"), exdir = "data")
} 

# Read in the probe conversion info - this step may take some time
probe.conversion <- readr::read_tsv(id.conversion.file, 
                                    progress = FALSE) %>% 
  dplyr::select("PROBEID", "ENSEMBL")

# Add annotation to imported author limma results 
author.full.results <- author.full.results %>%
  dplyr::inner_join(probe.conversion, by = c("affy_probe_ids" = "PROBEID")) %>%
  dplyr::mutate("ENSEMBL" = as.factor(ENSEMBL)) %>% 
  # Determine direction of fold change. 
  # Note up-directed genes will be TRUE, down-genes will be FALSE
  dplyr::mutate('direction' = logFC > 0)

# Take a look at the preview of this results table
author.full.results
```

### Summarize probe-level data into gene-level data
Because gene-level information is generally more biologically meaningful and
robust we will convert our Affymetrix probe IDs to Ensembl gene IDs (and also 
because this will match our refine.bio dataset).
We will find however, that most Ensembl gene IDs have many probes that align to 
them. 
In order to do this, we will figure out what the direction of the significant
probes are. 
Here we are only keeping adjusted p-values that are `< 0.05` this is a typical 
cutoff, but depending on your results and how long of gene lists you would like
to look at, you may need to adjust this. 
Next, we will group the probes by their associated Ensembl gene IDs and count
how many probesets are `up` and how many are `down` based on the `logical`
variable `direction` we made in the previous section. 

```{r}
# Summarize the direction of significant probes for each gene
direction.summary <- author.full.results %>% 
  # Keep only significant at 0.05 probes
  dplyr::filter(adj.P.Val < 0.05) %>% 
  # Group probes by their associated 
  dplyr::group_by(ENSEMBL) %>% 
  dplyr::summarize('up' = sum(direction), 
                   'down' = sum(!direction))

# Print out this dataset
direction.summary
```

Now we have a count of how many probes are significant in each direction.
We will summarize these gene level probe summaries into two gene lists. 
Some genes may have probesets that are both up and down.
For this analysis, we will only keep genes in the significance lists if all the
probesets are in the same direction.

```{r}
# Create an up-regulated genes list
author.up.genes <- direction.summary %>%
  # Upregulated genes are only those that have no significant downregulated 
  # probesets
  dplyr::filter(down == 0) %>%
  dplyr::pull(ENSEMBL) %>%
  as.character()

author.down.genes <- direction.summary %>%
  # Downregulated genes are only those that have no significant upregulated 
  # probesets
  dplyr::filter(up == 0) %>%
  dplyr::pull(ENSEMBL) %>%
  as.character()
```

## 4) Import and set up refine.bio processed data.
Data downloaded from refine.bio are in tab separated values (TSV) files and 
include a metadata in a separate TSV file. 
This data set was obtained from [refine.bio](https://www.refine.bio/). 

```{r}
# Put name of data file
refine.bio.data.filename <- file.path("data", "GSE37418.tsv")

# Unzip the file and direct it to the data folder
unzip(paste0(refine.bio.data.filename, ".zip"), exdir = "data")

# Read in data tsv file
refine.bio.df <- readr::read_tsv(refine.bio.data.filename, progress = FALSE) %>% 
  as.data.frame() %>%
  # Make the gene column the rownames so the gene names are out of the way for calculations
  tibble::column_to_rownames('X1') 
```

Set up the metadata for this set.

```{r}
# Metadata file name
metadata.filename <- file.path("data", "metadata_GSE37418.tsv")

# Read in metadata tsv file
metadata <- readr::read_tsv(metadata.filename) %>% 
  # Get rid of columns that have only NAs
  dplyr::select(-which(apply(is.na(.), 2, all)))

# Print out metadata so we can get an idea of what we have
metadata
```

Let's reformat our variable `subgroup` that we will be using for testing. 
To make the comparisons more reasonably similar, we will get rid of samples 
that *aren't* SHH, Group3, or Group4.

```{r}
# Reformat subgroup names to make Group 3 and 4 into "NonSHH"
metadata$subgroup <- gsub("G3|G4", "NonSHH", metadata$subgroup)

# Check out subgroup summary
summary(as.factor(metadata$subgroup))
```

To make the comparisons more reasonably similar to our imported dataset (which
only has SHH, Group3, or Group4), we will get rid of samples that *aren't* in 
one of these classifications.
Note that the `$` is a special character after `SHH` is just to signify that we 
only want samples that have `SHH` and end with those characters (So we are also 
excluding the `SHH OUTLIER` sample). 
Here's a [cheatsheet](https://www.rstudio.com/wp-content/uploads/2016/09/RegExCheatsheet.pdf)
on other special characters in R (known as regex - 'Regular Expressions')

```{r}
# Only keep samples that are SHH or Non-SHH (which is now both Group3 and Group4)
metadata <- metadata %>% 
  dplyr::filter(subgroup %in% c("SHH", "NonSHH"))
```

Make refine.bio metadata and data are same samples, in the same order.

```{r}
# Reorder/filter data to match metadata
refine.bio.df <- refine.bio.df[, match(metadata$refinebio_accession_code, 
                                       colnames(refine.bio.df))]

# Check if they are the same:
all.equal(colnames(refine.bio.df), metadata$refinebio_accession_code)
```

## 5) Do differential expression for refine.bio processed data
Here we are using the same model and set up as we used for the Northcott data
in `author_processed_DE.Rmd`. 
`limma` needs a numeric design matrix to signify which samples belong to which 
groups you are testing. 
Note that we are using the medulloblastoma subgroups as our variable for testing.
This is the same type of variable we used for our imported author processed 
dataset (See `author_processed_DE.Rmd`).

```{r Set up design matrix}
# Make subgroup a factor
metadata$subgroup <- as.factor(metadata$subgroup)

# Create the design matrix
des.mat <- model.matrix(~metadata$subgroup)

# Make the column name more informative
colnames(des.mat)[2] <- paste0(levels(subgroup), collapse = "vs")
```

## 6) Apply linear model
After applying our data to linear model, in this example we apply empirical Bayes
smoothing and Benjamini-Hochberg multiple testing correction (this was also the 
same methods applied to the Northcott data in `author_processed_DE.Rmd`).

```{r Apply linear model}
# Initial fit
fit <- lmFit(refine.bio.df, design = des.mat)

# eBayes for smoothing
fit <- eBayes(fit)
```

Obtain summary statistics:

```{r}
# Apply multiple testing correction and obtain stats
refine.bio.results <- topTable(fit, number = nrow(refine.bio.df)) %>%
  tibble::rownames_to_column("ENSEMBL") 
  
# Print out stats
refine.bio.results
```

Write these results to an output file.

```{r  Write results}
readr::write_tsv(refine.bio.results, file.path("results",
                                               "GSE37418_limma_results.tsv"))
```

### Create up/down-regulated gene lists for refine.bio results
Here we are using an adjusted p-value cutoff of `0.05`. 
We are not applying a magnitude cutoff for `logFC` but using logFC just to 
summarize direction of regulation. 
Depending on your own data, you may want to adjust these. 

```{r}
# Create up-regulated gene list for refinebio
refine.bio.up.genes <- refine.bio.results %>%
  # Apply cutoffs for p values and fold change direction to be up
  dplyr::filter(adj.P.Val < 0.05, logFC > 0) %>%
  # Reduce this to a gene ID vector list
  dplyr::pull(ENSEMBL) %>%
  as.character()

# Create down-regulated gene list for refinebio
refine.bio.down.genes <- refine.bio.results %>%
  dplyr::filter(adj.P.Val < 0.05, logFC < 0) %>%
  dplyr::pull(ENSEMBL) %>%
  as.character()
```

## 7) Set up exploration of overlap of the datasets differential expression
Here we will set up the data for making two Venn diagrams: one for overlap 
between the datasets for up-regulated genes, the other for down-regulated genes.
Determine overlap in up-regulated genes between datasets.

```{r}
# Make into named list
up.genes <- list('refine.bio' = refine.bio.up.genes, 
                 'author' = author.up.genes)

# Make into named list
down.genes <- list('refine.bio' = refine.bio.down.genes, 
                   'author' = author.down.genes)
```

Determine overlap in gene sets between datasets.

```{r}
# Calculate overlap of these gene lists:
up.overlap <- VennDiagram::calculate.overlap(up.genes)

# Calculate overlap of these gene lists:
down.overlap <- VennDiagram::calculate.overlap(down.genes)
```

## 8) Make Venn diagrams
### Overlap between up-regulated genes
Make Venn diagram of up-regulation results and save to png.

```{r}
# Make filename to save plot as
up.plot.file <- file.path("plots", 
                          "up-regulated_venn_northcott_vs_robinson.png")

# Make the Venn diagram
grid::grid.newpage();
up.venn.plot <- VennDiagram::draw.pairwise.venn(
  area1 = length(up.genes[[1]]),
  area2 = length(up.genes[[2]]),
  cross.area = length(up.overlap[[3]]),
  category = c("refine.bio", "author"),
  fill = c("blue", "yellow"),
  cex = 2,
  cat.cex = 1.5,
  cat.dist = c(-0.12, -0.13),
  cat.pos = c(170, 65),
  ext.pos = 0,
  ext.dist = -0.01,
  ext.length = .8,
  ext.line.lwd = 2,
  ext.line.lty = "dashed");
grid::grid.draw(up.venn.plot) # Draw plot
```

Save up-regulated genes Venn to a png.

```{r}
png(up.plot.file);
grid::grid.draw(up.venn.plot);
dev.off()
```

### Overlap between down-regulated genes
Do the same thing but for down-regulation results.

```{r}
# Make filename to save plot as
down.plot.file <- file.path("plots", 
                            "down-regulated_venn_northcott_vs_robinson.png")

# Make the Venn diagram
grid::grid.newpage();
down.venn.plot <- VennDiagram::draw.pairwise.venn(
  area1 = length(down.genes[[1]]),
  area2 = length(down.genes[[2]]),
  cross.area = length(down.overlap[[3]]),
  title = "Down-regulated Genes",
  category = c("refine.bio", "author"),
  fill = c("blue", "yellow"),
  cex = 2,
  cat.cex = 1.5,
  cat.dist = c(-0.11, -0.035),
  cat.pos = c(240, 120),
  ext.pos = 0,
  ext.dist = -0.01,
  ext.length = .8,
  ext.line.lwd = 2,
  ext.line.lty = "dashed");
grid::grid.draw(down.venn.plot) # Draw plot
```

Save down-regulated genes Venn to a png.

```{r}
png(down.plot.file);
grid::grid.draw(down.venn.plot);
dev.off()
```

## 9) Write overlapped gene list to tsv
Using `calculate.overlap`, we obtained a list of genes that were changed in both
datasets. 
If we want to extract the list of genes that are in both dataset, that is the 
third vector in the output object so we use `[[3]]`

```{r}
# Write the up-regulated gene overlap lists to tsv file
data.frame(up.overlap[[3]]) %>% 
  readr::write_tsv(file.path("results", "up-regulated_overlap_gene_list.tsv"))

# Do the same but for the down-regulated gene overlap list
data.frame(down.overlap[[3]]) %>% 
  readr::write_tsv(file.path("results", "down-regulated_overlap_gene_list.tsv"))
```

Print session info:

```{r}
sessionInfo()
```
