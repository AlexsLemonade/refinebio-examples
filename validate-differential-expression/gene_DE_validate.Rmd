---
title: "Comparing Differential Expression Analysis"
author: "ALSF CCDL - Candace Savonen"
output:   
  html_notebook: 
    toc: true
    toc_float: true
---

*Purpose*: This notebook takes data processed by refine.bio and compares the 
differential expression results to the author-submitted versions of the data.

## 1) Set up

```{r}
if (!("limma" %in% installed.packages())) {
  # Install limma
  BiocManager::install("limma", update = FALSE)
}
if (!("VennDiagram" %in% installed.packages())) {
  # Install VennDiagram
  BiocManager::install("VennDiagram", update = FALSE)
}
```

Attach the `limma` library:

```{r}
# Magrittr pipe
`%>%` <- dplyr::`%>%`

# Attach library
library(limma)
```

Set up output directories.

```{r}
# Make a results directory if it isn't created yet
if (!dir.exists("results")) {
  dir.create("results")
}
# Make a plots directory if it isn't created yet
if (!dir.exists("plots")) {
  dir.create("plots")
}
```

## 2) Import differential expression results from Northcott dataset
Import the `limma` results. 
If you'd like to see how we generated these results with `limma`, see
`author_processed_DE.Rmd` in this folder.

```{r}
# Load in the summary statistics from limma run
author.full.results <- readr::read_tsv(file.path("results", 
                                                 "GSE37382_limma_results.tsv")) 
```

## 3) Convert the differentially expressed gene identifiers to Ensembl gene IDs
In refine.bio all IDs are converted to Ensembl gene IDs in the harmonization 
pipeline.
Here we need to convert our Affymetrix transcript cluster IDs into Ensembl gene
IDs so we can compare our datasets. 
If you are using this notebook for your own data, and need more information on
how to id conversion, you can look at `ensembl_id_convert.Rmd` in this repository
for more information. 
You can also use the [id conversion repository prepared by the CCDL.](https://github.com/AlexsLemonade/identifier-refinery) 
The pre-made id conversion key files themselves for refine.bio supported 
microarray platforms can be downloaded from [Zenodo](https://zenodo.org/record/1322711#.XLdJb-tKiXE). 

```{r}
# Unzip hugene11st id conversion file obtained from identifier refinery
id.conversion.file <- file.path("data", "hugene11st.tsv") 
if (!file.exists(id.conversion.file)) {
  unzip(paste0(id.conversion.file, ".zip"), exdir = "data")
} 

# Read in the probe conversion info - this step may take some time
probe.conversion <- readr::read_tsv(id.conversion.file, 
                                    progress = FALSE) %>% 
  dplyr::select("PROBEID", "ENSEMBL")

# Add annotation to imported author limma results 
author.full.results <- author.full.results %>%
  dplyr::inner_join(probe.conversion, by = c("affy_probe_ids" = "PROBEID")) %>%
  dplyr::mutate("ENSEMBL" = as.factor(ENSEMBL)) %>% 
  # Calculate fold change
  dplyr::mutate('fold.change' = SHH/Non_SHH) %>%
  # Determine direction of fold change
  dplyr::mutate('direction' = (fold.change > 1))
```

Most of the genes have many probes that align to them. 
So in order to make these data comparable to to refine.bio data, we
need to summarize at the gene level. 
In order to do this, we will figure out what the direction of the significant
probes are. 

```{r}
# Summarize the direction of significant probes for each gene
direction.summary <- author.full.results %>% 
  dplyr::filter(adj.P.Val < 0.05) %>% 
  dplyr::group_by(ENSEMBL) %>% 
  dplyr::summarize('up' = sum(direction), 
                   'down' = sum(!direction))

# Print out this dataset
direction.summary
```

Make up-regulation and down-regulation gene lists.

```{r}
# Create an up-regulated genes list
author.up.genes <- direction.summary %>%
  dplyr::filter(up > down) %>%
  dplyr::pull(ENSEMBL) %>%
  as.character()

author.down.genes <- direction.summary %>%
  dplyr::filter(up < down) %>%
  dplyr::pull(ENSEMBL) %>%
  as.character()
```

## 4) Import and set up refine.bio processed data.
Data downloaded from refine.bio are in tab separated values (TSV) files and 
include a metadata in a separate TSV file. 
This data set was obtained from [refine.bio](https://www.refine.bio/). 

```{r}
# Put name of data file
refine.bio.data.filename <- file.path("data", "GSE37418.tsv")

# Unzip the file and direct it to the data folder
unzip(paste0(refine.bio.data.filename, ".zip"), exdir = "data")

# Read in data tsv file
refine.bio.df <- readr::read_tsv(refine.bio.data.filename, progress = FALSE) %>% 
  as.data.frame() %>%
  # Make the gene column the rownames so the gene names are out of the way for calculations
  tibble::column_to_rownames('X1') 
```

Set up the metadata for this set.

```{r}
# Metadata file name
metadata.filename <- file.path("data", "metadata_GSE37418.tsv")

# Read in metadata tsv file
metadata <- readr::read_tsv(metadata.filename) %>% 
  # Get rid of columns that have only NAs
  dplyr::select(-which(apply(is.na(.), 2, all)))

# Print out metadata so we can get an idea of what we have
metadata
```

Let's reformat our variable `subgroup` that we will be using for testing. 
To make the comparisons more reasonably similar, we will get rid of samples 
that *aren't* SHH, Group3, or Group4.

```{r}
# Reformat subgroup names to make Group 3 and 4 into "Non_SHH"
metadata$subgroup <- gsub("G3|G4", "Non_SHH", metadata$subgroup)

# Check out subgroup summary
summary(as.factor(metadata$subgroup))
```

To make the comparisons more reasonably similar to our imported dataset (which
only has SHH, Group3, or Group4), we will get rid of samples that *aren't* in 
one of these classifications.
Note that the `$` is a special character after `SHH` is just to signify that we 
only want samples that have `SHH` and end with those characters (So we are also 
excluding the `SHH OUTLIER` sample). 
Here's a [cheatsheet](https://www.rstudio.com/wp-content/uploads/2016/09/RegExCheatsheet.pdf)
on other special characters in R (known as regex - 'Regular Expressions')

```{r}
# Only keep samples that are SHH or Non-SHH (which is now both Group3 and Group4)
metadata <- metadata %>% 
  dplyr::filter(subgroup %in% c("SHH", "Non_SHH"))
```

Make refine.bio metadata and data are same samples, in the same order.

```{r}
# Reorder/filter data to match metadata
refine.bio.df <- refine.bio.df[, match(metadata$refinebio_accession_code, 
                                       colnames(refine.bio.df))]

# Check if they are the same:
all.equal(colnames(refine.bio.df), metadata$refinebio_accession_code)
```

## 5) Do differential expression for refine.bio
`limma` needs a numeric design matrix to signify which samples belong to which 
groups you are testing. 
Note that we are using the medulloblastoma subgroups as our variable for testing.
This is the same type of variable we used for our imported author processed 
dataset (See `author_processed_DE.Rmd`).

```{r Set up design matrix}
# Make subgroup a factor
metadata$subgroup <- as.factor(metadata$subgroup)

# Create the design matrix
des.mat <- model.matrix(~metadata$subgroup)

# Change names of columns in design matrix to match
colnames(des.mat) <- levels(metadata$subgroup)
```

## 6) Apply linear model
After applying our data to linear model, in this example we apply empirical Bayes
smoothing and Benjamini-Hochberg multiple testing correction. 

```{r Apply linear model}
# Initial fit
fit <- lmFit(refine.bio.df, des.mat)

# eBayes for smoothing
refine.bio.fit <- eBayes(fit)
```

Obtain summary statistics:

```{r}
# Apply multiple testing correction and obtain stats
refine.bio.results <- topTable(refine.bio.fit, number = nrow(refine.bio.df)) %>%
  tibble::rownames_to_column("ENSEMBL") %>% 
  dplyr::mutate('fold.change' = SHH/Non_SHH) 
  
# Print out stats
refine.bio.results
```

```{r}
# Create up-regulated gene list for refinebio
refine.bio.up.genes <- refine.bio.results %>%
  dplyr::filter(adj.P.Val < 0.05, fold.change > 1) %>%
  dplyr::pull(ENSEMBL) %>%
  as.character()

# Create down-regulated gene list for refinebio
refine.bio.down.genes <- refine.bio.results %>%
  dplyr::filter(adj.P.Val < 0.05, fold.change < 1) %>%
  dplyr::pull(ENSEMBL) %>%
  as.character()
```

Write these results to an output file.

```{r  Write results}
readr::write_tsv(refine.bio.results, file.path("results",
                                               "GSE37418_limma_results.tsv"))
```

## 7) Set up exploration of overlap of the datasets differential expression
Combine `limma` results into one dataset.
Here we will set up the data for making two Venn diagrams: one for overlap 
between the datasets for up-regulated genes, the other for down-regulated genes.
In order to determine direction, we will calculate fold change here and make 
those as new variables. 
Determine overlap in up-regulated genes between datasets.
Here we are defining significantly changed genes as those with adjusted p values
less than 0.05. 
We determine direction based on the fold change calculated above. 

```{r}
# Make into named list
up.genes <- list('refine.bio' = refine.bio.up.genes, 
                 'author' = author.up.genes)

# Make into named list
down.genes <- list('refine.bio' = refine.bio.down.genes, 
                   'author' = author.down.genes)
```

Determine overlap in down-regulated genes between datasets.

```{r}
# Calculate overlap of these gene lists:
up.overlap <- VennDiagram::calculate.overlap(up.genes)

# Calculate overlap of these gene lists:
down.overlap <- VennDiagram::calculate.overlap(down.genes)
```

## 8) Make Venn diagrams
### Overlap between up-regulated genes
Make Venn diagram of up-regulation results and save to png.

```{r}
# Make filename to save plot as
up.plot.file <- file.path("plots", 
                          "up-regulated_venn_northcott_vs_robinson.png")

# Make the Venn diagram
grid::grid.newpage();
up.venn.plot <- VennDiagram::draw.pairwise.venn(
  area1 = length(up.genes[[1]]),
  area2 = length(up.genes[[2]]),
  cross.area = length(up.overlap[[3]]),
  category = c("refine.bio", "author"),
  fill = c("blue", "yellow"),
  cex = 2,
  cat.cex = 1.5,
  cat.dist = c(-0.04, -0.05),
  cat.pos = c(270, 70),
  ext.pos = 0,
  ext.dist = -0.01,
  ext.length = .8,
  ext.line.lwd = 2,
  ext.line.lty = "dashed");
grid::grid.draw(up.venn.plot) # Draw plot
```

Save up-regulated genes Venn to a png.

```{r}
png(up.plot.file);
grid::grid.draw(up.venn.plot);
dev.off()
```

### Overlap between down-regulated genes
Do the same thing but for down-regulation results.

```{r}
# Make filename to save plot as
down.plot.file <- file.path("plots", 
                            "down-regulated_venn_northcott_vs_robinson.png")

# Make the Venn diagram
grid::grid.newpage();
down.venn.plot <- VennDiagram::draw.pairwise.venn(
  area1 = length(down.genes[[1]]),
  area2 = length(down.genes[[2]]),
  cross.area = length(down.overlap[[3]]),
  title = "Down-regulated Genes",
  category = c("refine.nio", "author"),
  fill = c("blue", "yellow"),
  cex = 2,
  cat.cex = 1.5,
  cat.dist = c(-0.04, -0.035),
  cat.pos = c(270, 90),
  ext.pos = 0,
  ext.dist = -0.01,
  ext.length = .8,
  ext.line.lwd = 2,
  ext.line.lty = "dashed");
grid::grid.draw(down.venn.plot) # Draw plot
```

Save down-regulated genes Venn to a png.

```{r}
png(down.plot.file);
grid::grid.draw(down.venn.plot);
dev.off()
```

## 8) Write overlapped gene list to tsv
Using `calculate.overlap`, we obtained a list of genes that were changed in both
datasets. 
If we want to extract the list of genes that are in both dataset, that is the 
third vector in the output object so we use `[[3]]`
```{r}
# Write the up-regulated gene overlap lists to tsv file
data.frame(up.overlap[[3]]) %>% 
  readr::write_tsv(file.path("results", "up-regulated_overlap_gene_list.tsv"))

# Do the same but for the down-regulated gene overlap list
data.frame(down.overlap[[3]]) %>% 
  readr::write_tsv(file.path("results", "down-regulated_overlap_gene_list.tsv"))
```

Print session info:

```{r}
sessionInfo()
```
