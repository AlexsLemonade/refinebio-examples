---
title: "Comparing Differential Expression Analysis"
author: "ALSF CCDL - Candace Savonen"
output:   
  html_notebook: 
    toc: true
    toc_float: true
---

*Purpose*: This notebook takes data processed byrefine.bio and compares the 
differential expression results to the author submitted versions of the data.

## 1) Install libraries
This script uses the bioconductor R package limma to identify differentially 
expressed genes.  
The full guide on [limma](https://bioconductor.org/packages/release/bioc/vignettes/limma/inst/doc/usersguide.pdf) 
shows examples of limma functions. 
<i>Citation</i>: Ritchie ME, Phipson B, Wu D, Hu Y, Law CW, Shi W, Smyth GK (2015). 
“limma powers differential expression analyses for RNA-sequencing and microarray
studies.” Nucleic Acids Research, 43(7), e47. 

```{r Install limma}
if (!("limma" %in% installed.packages())) {
  # Install limma
  BiocManager::install("limma", update = FALSE)
}
if (!("GEOquery" %in% installed.packages())) {
  # Install limma
  BiocManager::install("GEOquery", update = FALSE)
}
```

Attach the `limma` library:

```{r}
# Magrittr pipe
`%>%` <- dplyr::`%>%`

# Attach library
library(limma)
```

Set up output directories.

```{r}
# Make a results directory if it isn't created yet
if (!dir.exists("results")) {
  dir.create("results")
}
# Make a plots directory if it isn't created yet
if (!dir.exists("plots")) {
  dir.create("plots")
}
```

## 2) Import and set up refine.bio processed data.
Data downloaded from refine.bio are in tab separated values ("tsv") files and 
include a metadata in a separate tsv file. 
These data set was obtained from [refine.bio](https://www.refine.bio/). 

```{r}
# Put name of data file
refine.bio.data.filename <- file.path("data", "GSE37382.tsv")

# Unzip the file and direct it to the data folder
unzip(paste0(refine.bio.data.filename, ".zip"), exdir = "data")

# Read in data tsv file
refine.bio.df <- readr::read_tsv(refine.bio.data.filename, progress = FALSE) %>% 
  # Make the gene column the rownames so the gene names are out of the way for calculations
  tibble::column_to_rownames('X1') 
```

## 3) Import and set up author processed data from GEO

```{r}
# Download author processed data file directly to `data` folder
GEOquery::getGEO("GSE37382", destdir = "data", GSEMatrix = TRUE)

# unzip the .gz file with the gene matrix in it
GEOquery::gunzip(file.path("data", "GSE37382_series_matrix.txt.gz"))

# Read in the author processed gene matrix
author.df <- readr::read_tsv(file.path("data", "GSE37382_series_matrix.txt"), 
                             comment = "!")
```
Convert the Affy IDs to gene ids

```{r}

```

## 4) Import the metadata for this dataset

```{r}
# Metadata file name
metadata.filename <- file.path("data", "metadata_GSE37382.tsv")

# Read in metadata tsv file
metadata <- readr::read_tsv(metadata.filename) %>% 
  # Get rid of columns that have only NAs
  dplyr::select(-which(apply(is.na(.), 2, all)))

# Print out metadata so we can get an idea of what we have
metadata
```

## 4) Set up design matrix
limma needs a numeric design matrix to signify which are treatment and control
samples. 
Here we are using the treatments supplied in the metadata to create
a design matrix where the "none" samples are assigned `0` and the "amputated"
samples are assigned `1`.
Note that the metadata variables that signify the treatment groups might be
different in across datasets and might not always be underneath the "treatment"
category.

```{r Set up design matrix}
# Check if the samples are in the same order in the metadata and data files
# Have to use gsub to get rid of problematic punctuation and space so they are 
# matching
tmp <- match(gsub("X|\\.", "", colnames(df)), metadata$geo_accession)

# Use the indices identified in the line above to rearrange the design matrix to
# be in the same order as the data
# Create the design matrix
des.mat <- model.matrix(~metadata$genotype.variation[tmp])
```

## 5) Apply linear model
After applying our data to linear model, in this example we apply empircal Bayes
smoothing and Benjamini-Hochberg multiple testing correction. 
The `topTable` function default is to use Benjamini Hochberg but this can be
changed to a different method using the `adjust.method` argument.

```{r Apply linear model}
# Apply linear model to data
fit <- lmFit(df, design = des.mat)

# Apply empirical Bayes to smooth standard errors
fit <- eBayes(fit)

# Apply multiple testing correction and obtain stats
stats <- topTable(fit, number = nrow(df))
```

## 6) Explore fitness of model
Here we will use two different plots that can be used to assess the quality of
your model. A guide to the interpretation of these plots and other statistics for 
gene expression data can be found [here](http://www.nathalievialaneix.eu/doc/pdf/tutorial-rnaseq.pdf).

```{r  Explore model, warning=FALSE}
# Create Q-Q plot
qqt(fit$t, pch = 16, cex = 0.2);
abline(0,1)

# Create volcano plot 
volcanoplot(fit, main = "Volcano Plot")
```

## 7) Write statistics to output results file

```{r  Write results}
readr::write_tsv(stats, file.path("results", "GSE71270_limma_results.tsv"))
```

Print session info:

```{r}
# Print session info 
sessionInfo()
```
